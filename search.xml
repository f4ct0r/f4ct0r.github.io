<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>call apply bind的作用</title>
      <link href="/2022/06/26/programs/js/call_apply_bind%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2022/06/26/programs/js/call_apply_bind%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><code>call</code>、<code>apply</code>、<code>bind</code>这三种都是用于改变this的指向，让默认的this转变为自己想要的指向</p><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p><code>call</code>可以提供参数来改变<code>this</code>的指向，但是<code>call</code>会立即调用该函数</p><pre class=" language-javascript"><code class="language-javascript">fun<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'f4ct0r'</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该函数调用时，由于修改了this的指向，所以并不指向window或global，而是指向对象o</p><p>所以调用返回</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'f4ct0r'</span> <span class="token punctuation">}</span><span class="token number">3</span></code></pre><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p><code>apply</code>方法也可以改变<code>this</code>的指向，并且也是立即调用，不同的是该方法传递到函数内部的形参是数组形式</p><pre class=" language-javascript"><code class="language-javascript">fun<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> <span class="token punctuation">[</span>argArray<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'f4ct0r'</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该函数调用时，由于修改了this的指向，所以并不指向window或global，而是指向对象o</p><p>所以调用返回</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'f4ct0r'</span> <span class="token punctuation">}</span><span class="token number">3</span></code></pre><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind</code>方法也可以改变<code>this</code>的指向，但该方法不是立即调用，而是仅将函数的<code>this</code>修改，并且返回一个由改变<code>this</code>指向和初始参数的原函数的拷贝</p><pre class=" language-javascript"><code class="language-javascript">fun<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">'f4ct0r'</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> newFn <span class="token operator">=</span> fn<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">newFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该函数调用时，由于修改了this的指向，所以并不指向window或global，而是指向对象o</p><p>所以调用返回</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'f4ct0r'</span> <span class="token punctuation">}</span><span class="token number">3</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>三个函数都能改变<code>this</code>的指向</li><li><code>call</code>和<code>apply</code>会立即调用函数，并改变<code>this</code>的指向</li><li><code>call</code>传递<code>arg1 arg2</code>这样的参数，<code>apply</code>传递数组</li><li><code>bind</code>不会立即调用函数，而是返回一个修改了<code>this</code>指向的原函数拷贝</li></ol><p>一般的应用场景：</p><ul><li><code>call</code>一般用于继承</li><li><code>apply</code>一般用于参数为数组</li><li><code>bind</code>一般用于异步调用的</li></ul>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this的指向</title>
      <link href="/2022/06/26/programs/js/this%E7%9A%84%E6%8C%87%E5%90%91/"/>
      <url>/2022/06/26/programs/js/this%E7%9A%84%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p><code>this</code>的指向问题在学习js的时候经常会搞错，<code>this</code>的指向是当函数被调用的时候确定的，调用方式不同决定了<code>this</code>的指向不同<br>，<strong>一般指向调用者</strong></p><table><thead><tr><th>调用方式</th><th>this指向</th></tr></thead><tbody><tr><td>普通函数调用</td><td>window&#x2F;global</td></tr><tr><td>构造函数调用</td><td>实例对象，原型方法里也指向实例对象</td></tr><tr><td>对象方法调用</td><td>该方法所属对象</td></tr><tr><td>事件绑定方法</td><td>绑定事件对象</td></tr><tr><td>定时器函数</td><td>window&#x2F;global</td></tr><tr><td>立即执行函数</td><td>window&#x2F;global</td></tr></tbody></table><h2 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 打印为window或global对象</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该函数在调用之后，打印为window或global对象，因为在js或nodejs中默认全局对象为window或global</p><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>    fn<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 打印为对象o，因为调用者为o</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>o<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该函数调用者为o对象，所以this指向该对象</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">O</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// this指向当前的实例对象</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">O</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该函数调用者为实例化的对象，对象实例化在<code>new</code>的过程中，会自动调用<code>constructor()</code>函数</p><h2 id="绑定事件函数"><a href="#绑定事件函数" class="headerlink" title="绑定事件函数"></a>绑定事件函数</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">let</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>btn<span class="token punctuation">.</span>click <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this指向btn，因为btn是该函数的调用者</span><span class="token punctuation">}</span></code></pre><p>该函数调用者为btn，所以<code>this</code>指向btn</p><h2 id="定时器函数"><a href="#定时器函数" class="headerlink" title="定时器函数"></a>定时器函数</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this指向window或global</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span></code></pre><p>由于全局对象为window或global，所以该回调函数的调用者为window或global，所以<code>this</code>指向windows或global</p><h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>由于全局对象为window或global，所以立即执行函数的调用者为window或global，所以<code>this</code>指向windows或global</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logstash_sql_last_run填坑</title>
      <link href="/2022/06/06/middleware/elk/logstash_sql_last_run%E5%A1%AB%E5%9D%91/"/>
      <url>/2022/06/06/middleware/elk/logstash_sql_last_run%E5%A1%AB%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天在使用logstash来读取mssql数据时，发现logstash的sql_last_run的值一直没有更新，导致一直在重复读取数据，研究了好久终于搞清楚问题的原因</p><h2 id="最初的想法"><a href="#最初的想法" class="headerlink" title="最初的想法"></a>最初的想法</h2><p>由于目标数据库会每天存储在当天的数据库里，所以在读取的过程中需要进行跨库读取，一开始我们决定使用<code>ID</code>来进行游标，<code>sql_last_run</code>的值就会是上一次读取的最后一个<code>ID</code></p><p>我们最初的配置如下：</p><pre class=" language-text"><code class="language-text">input {    jdbc {        jdbc_driver_library => "/opt/logstash/sqljdbc_10.2/chs/mssql-jdbc-10.2.0.jre8.jar"        jdbc_driver_class => "com.microsoft.sqlserver.jdbc.SQLServerDriver"        jdbc_connection_string => "jdbc:sqlserver://server:1433;databasename=database"        jdbc_user => "user"        jdbc_password => "password"        jdbc_default_timezone => "Asia/Shanghai"        use_column_value => true        tracking_column => "ID"  # <=注意这里是大写的ID        record_last_run => true        schedule => "* * * * *"        last_run_metadata_path => "/opt/logstash/cache/.jdbc_last_run"        statement => "            declare @nowtime varchar(32);            declare @sql varchar(8000);            set @nowtime=(Select CONVERT(varchar(100), GETDATE(), 112));            set @sql='select * FROM [DBNAME.' + @nowtime + '] where ID > :sql_last_run order by ID ASC';            exec(@sql);        "    }}</code></pre><p>结果运行起来之后发现直接报错，logstash说和服务器压根儿没法建立连接，原因是不能和服务器建立一个加密的链路</p><pre class=" language-text"><code class="language-text">Unable to connect to database. Tried 1 times {:error_message=>"Java::ComMicrosoftSqlserverJdbc::SQLServerException: The driver could not establish a secure connection to SQL Server by using Secure Sockets Layer (SSL) encryption. Error: \"sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\". ClientConnectionId:6a991eaa-0b7e-41ee-8e82-22c2f23d12a6"}</code></pre><p>看报错才知道服务端只允许加密连接的建立，于是在配置里的连接字符串里加上加密的配置</p><pre class=" language-text"><code class="language-text">jdbc_connection_string => "jdbc:sqlserver://server:1433;databasename=database;encrypt=true;trustServerCertificate=true;"</code></pre><p>重新跑一边logstash，没有报错，觉得还挺顺利</p><h2 id="奇坑的配置项"><a href="#奇坑的配置项" class="headerlink" title="奇坑的配置项"></a>奇坑的配置项</h2><p>但随着日志的打印，发现老是在重复读取数据，看了看配置没发现任何问题，并且<code>/opt/logstash/cache/.jdbc_last_run</code>里序列化的值，难道是logstash出bug了？</p><p>一顿Google后才知道原来坑在<code>tracking_column</code>上，<code>tracking_column</code>这个配置默认只认识小写的值，也就是说我配置的<code>ID</code>对logstash来说根本不认识，除非将<code>lowercase_column_names</code>的值置为<code>false</code>，但是这两点在官方文档上都没有说明。。。。。坑啊。。。。</p><p>修改成小写后重新运行，发现总算是运行正常，<code>/opt/logstash/cache/.jdbc_last_run</code>里的<code>id</code>值也在改变，看上去非常的完美</p><h2 id="id产生的问题"><a href="#id产生的问题" class="headerlink" title="id产生的问题"></a>id产生的问题</h2><p>结果到了第二天，发现根本没有任何数据生成，这是为什么呢？也没有任何报错，哪里又出bug了？</p><p>在查看了<code>/opt/logstash/cache/.jdbc_last_run</code>的值之后发现是一个很大的<code>id</code>值，通过where条件的值来看，只有大于这个<code>id</code>的值才会有数据输出，那可不是没数据嘛。。。。</p><p>那看来对于这种需要每天查询不同数据库的情况来说，用<code>id</code>来做游标进行偏移并不可取，所以想到通过时间来进行偏移，这样就不用担心这个问题了</p><h2 id="最终的结果"><a href="#最终的结果" class="headerlink" title="最终的结果"></a>最终的结果</h2><p>所以，最终的配置如下，总算是完美的跑起来了。。。。</p><pre class=" language-text"><code class="language-text">input {    jdbc {        jdbc_driver_library => "/opt/logstash/sqljdbc_10.2/chs/mssql-jdbc-10.2.0.jre8.jar"        jdbc_driver_class => "com.microsoft.sqlserver.jdbc.SQLServerDriver"        jdbc_connection_string => "jdbc:sqlserver://server:1433;databasename=database;encrypt=true;trustServerCertificate=true;"        jdbc_user => "user"        jdbc_password => "password"        jdbc_default_timezone => "Asia/Shanghai"        use_column_value => true        tracking_column => "time"        tracking_column_type => "timestamp"        record_last_run => true        schedule => "* * * * *"        last_run_metadata_path => "/opt/logstash/cache/.jdbc_last_run"        statement => "            declare @nexttime varchar(100);            declare @nowtime varchar(32);            declare @sql varchar(8000);            set @nowtime=(Select CONVERT(varchar(100), GETDATE(), 112));            set @sql='select * FROM [DBNAME.' + @nowtime + '] where time > ':sql_last_value' order by time ASC';            exec(@sql);        "    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> elk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logstash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes proxy</title>
      <link href="/2022/06/05/middleware/kubernetes/kubernetes_proxy/"/>
      <url>/2022/06/05/middleware/kubernetes/kubernetes_proxy/</url>
      
        <content type="html"><![CDATA[<p>kubernetes一共存在3种proxy</p><h2 id="kubectl-proxy"><a href="#kubectl-proxy" class="headerlink" title="kubectl proxy"></a>kubectl proxy</h2><p>该proxy作用于接收kubernetes API的前端，也就是说当使用了kubectl proxy之后，访问kubernetes API的请求会先被代理到该proxy，然后再被转发到REST API，这种proxy可以提供简单的安全机制来限制可以访问API的用户</p><h2 id="kubernetes-proxy-api"><a href="#kubernetes-proxy-api" class="headerlink" title="kubernetes proxy api"></a>kubernetes proxy api</h2><p>这类接口的作用是代理REST请求，即kubernetes api server把收到的REST请求转发到某个node的kubelet守护进程的REST端口上，由该kubelet进程负责响应</p><h2 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h2><p>在kubernetes集群的每个node上都会运行一个kube-proxy服务进程，这个进程可以看作service的透明代理兼负载均衡器，其核心功能是将到某个service的访问请求转发到后端的多个Pod实例上</p>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes network error</title>
      <link href="/2022/06/05/middleware/kubernetes/kubernetes_network_error/"/>
      <url>/2022/06/05/middleware/kubernetes/kubernetes_network_error/</url>
      
        <content type="html"><![CDATA[<p>创建pod时一直处于ContainerCreating状态，通过describe查看详细情况，发现cni插件报错</p><pre class=" language-shell"><code class="language-shell">[root@master0 ~]# kubectl describe pod registry-7dd988f576-zdzsr -n kube-systemName:           registry-7dd988f576-zdzsrNamespace:      kube-systemNode:           10.0.81.102/10.0.81.102Start Time:     Mon, 25 Mar 2019 10:18:57 +0800Labels:         app=registry                pod-template-hash=3885449132Annotations:    <none>Status:         PendingIP:Controlled By:  ReplicaSet/registry-7dd988f576Containers:  registry:    Container ID:    Image:          10.0.81.102:5000/google_containers/registry:1.1.0    Image ID:    Port:           5000/TCP    Host Port:      0/TCP    State:          Waiting      Reason:       ContainerCreating    Ready:          False    Restart Count:  0    Liveness:       http-get http://:5000/v2/ delay=10s timeout=5s period=10s #success=1 #failure=5    Environment:    <none>    Mounts:      /var/lib/registry from docker-data (rw)      /var/run/secrets/kubernetes.io/serviceaccount from default-token-lrtb4 (ro)Conditions:  Type           Status  Initialized    True  Ready          False  PodScheduled   TrueVolumes:  docker-data:    Type:          HostPath (bare host directory volume)    Path:          /data/registry    HostPathType:  Directory  default-token-lrtb4:    Type:        Secret (a volume populated by a Secret)    SecretName:  default-token-lrtb4    Optional:    falseQoS Class:       BestEffortNode-Selectors:  master=masterTolerations:     <none>Events:  Type     Reason                  Age                 From                  Message  ----     ------                  ----                ----                  -------  Warning  FailedScheduling        23m (x26 over 29m)  default-scheduler     0/3 nodes are available: 1 node(s) were not ready, 1 node(s) were out of disk space, 2 node(s) didn't match node selector.  Warning  FailedScheduling        15m (x26 over 22m)  default-scheduler     0/3 nodes are available: 1 node(s) were not ready, 1 node(s) were out of disk space, 2 node(s) didn't match node selector.  Normal   SuccessfulMountVolume   14m                 kubelet, 10.0.81.102  MountVolume.SetUp succeeded for volume "docker-data"  Normal   SuccessfulMountVolume   14m                 kubelet, 10.0.81.102  MountVolume.SetUp succeeded for volume "default-token-lrtb4"  Warning  FailedCreatePodSandBox  14m (x12 over 14m)  kubelet, 10.0.81.102  Failed create pod sandbox: rpc error: code = Unknown desc = NetworkPlugin cni failed to set up pod "registry-7dd988f576-zdzsr_kube-system" network: failed to set bridge addr: "docker0" already has an IP address different from 10.2.89.1/24  Warning  FailedCreatePodSandBox  9m (x123 over 12m)  kubelet, 10.0.81.102  Failed create pod sandbox: rpc error: code = Unknown desc = NetworkPlugin cni failed to set up pod "registry-7dd988f576-zdzsr_kube-system" network: failed to allocate for range 0: no IP addresses available in range set: 10.2.89.1-10.2.89.254  Normal   SandboxChanged          4m (x441 over 14m)  kubelet, 10.0.81.102  Pod sandbox changed, it will be killed and re-created.  Warning  FailedSync              3m                  kubelet, 10.0.81.102  error determining status: rpc error: code = Unknown desc = Error: No such container: 0b436f239e5176c75cff98c775e8bdd619686f91915758e2c5ba1b5f51de458d  Normal   SuccessfulMountVolume   3m                  kubelet, 10.0.81.102  MountVolume.SetUp succeeded for volume "docker-data"  Normal   SuccessfulMountVolume   3m                  kubelet, 10.0.81.102  MountVolume.SetUp succeeded for volume "default-token-lrtb4"  Warning  FailedCreatePodSandBox  3m (x11 over 3m)    kubelet, 10.0.81.102  Failed create pod sandbox: rpc error: code = Unknown desc = NetworkPlugin cni failed to set up pod "registry-7dd988f576-zdzsr_kube-system" network: failed to allocate for range 0: no IP addresses available in range set: 10.2.89.1-10.2.89.254  Normal   SandboxChanged          3m (x11 over 3m)    kubelet, 10.0.81.102  Pod sandbox changed, it will be killed and re-created.</code></pre><p>排查记录：</p><ol><li>查看flannel.1与docker0的IP是否处于同一网段</li><li>然后通过错误信息<code>network: failed to allocate for range 0: no IP addresses available in range set: 10.2.89.1-10.2.89.254</code>怀疑该网段的所有IP都被占用</li><li>查看<code>/var/lib/cni/networks/flannel/</code>中的文件，发现该网段的IP都有被记录</li><li>删除<code>/var/lib/cni/flannel/*</code>和<code>/var/lib/cni/networks/flannel/*</code>即可解决问题</li></ol><p>出现该问题的具体原因还未知，可能时cni的一个<br><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1532965">bug</a></p>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>no IP addresses available in range set</title>
      <link href="/2022/06/05/middleware/kubernetes/no_IP_addresses_available_in_range_set/"/>
      <url>/2022/06/05/middleware/kubernetes/no_IP_addresses_available_in_range_set/</url>
      
        <content type="html"><![CDATA[<p>Error adding network: failed to allocate for range 0: no IP addresses available in range set:</p><p>解决方案：</p><ol><li>关闭kubernetes的所有服务(包括docker)</li><li>rm -fr &#x2F;var&#x2F;lib&#x2F;cni&#x2F;* &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;*</li><li>ifdown flannel.1</li><li>ifdown docker0</li><li>重启kubernetes所有服务</li></ol>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes CA签名的双向认证</title>
      <link href="/2022/06/05/middleware/kubernetes/Kubernetes_CA%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/"/>
      <url>/2022/06/05/middleware/kubernetes/Kubernetes_CA%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>在一个安全的内网环境中，Kubernetes的各个组件可以通过apiserver提供的非安全端口8080进行通信。但是如果涉及到apiserver需要对外提供服务或者容器需要调用apiserver获取集群中的信息，更安全的做法是使用HTTPS的安全机制。Kubernetes提供了基于CA签名的双向认证及基于HTTP Base或Token的认证方式，其中基于CA证书的安全系数最高。</p><h2 id="Master节点"><a href="#Master节点" class="headerlink" title="Master节点"></a>Master节点</h2><h3 id="kube-apiserver配置"><a href="#kube-apiserver配置" class="headerlink" title="kube-apiserver配置"></a>kube-apiserver配置</h3><p>首先在master上生成apiserver需要用到的CA证书及服务器公私钥，这里需要保证CA证书的Comman Name和hostname一致，否则证书会认证失败</p><p>并且CA证书在使用的过程中，需要预先安装在系统中，使系统信任该证书</p><pre class=" language-shell"><code class="language-shell">openssl genrsa -out ca.key 2048openssl req -x509 -new -nodes -key ca.key -subj "/CN=k8s-master" -days 5000 -out ca.crtyum install ca-certificates -yupdate-ca-trust force-enablecp ca.crt /etc/pki/ca-trust/source/anchors/update-ca-trust extract</code></pre><p>为master生成公私钥时，需要准备master_ssl.cnf文件，该文件用于x509 v3版本的证书。在该文件中主要设置master的hostname、IP地址及Kubernetes Master Service的虚拟服务名称（kubernetes.default等）和该虚拟服务的ClusterIP地址。其中alt_names下面的键值对必须要有，否则会出现SAN错误的问题。</p><pre class=" language-text"><code class="language-text">[req]req_extensions = v3_reqdistinguished_name = req_distinguished_name[req_distinguished_name][v3_req]basicConstraints = CA:FALSEkeyUsage = nonRepudiation, digitalSignature, keyEnciphermentsubjectAltName = @alt_names[alt_names]DNS.1 = kubernetesDNS.2 = kubernetes.defaultDNS.3 = kubernetes.default.svcDNS.4 = kubernetes.default.svc.cluster.localDNS.5 = k8s-masterIP.1 = 169.169.0.1IP.2 = 10.0.83.61</code></pre><pre class=" language-shell"><code class="language-shell">openssl genrsa -out server.key 2048openssl req -new -key server.key -subj "/CN=k8s-master" -config master_ssl.cnf -out server.csropenssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 5000 -extensions v3_req -extfile master_ssl.cnf -out server.crt</code></pre><p>而在kube-apiserver的配置文件中需要通过–client-ca-file, –tls-private-key, –tls-cert-file三个参数指定CA证书，服务端私钥，服务端公钥<br>kube-api.conf</p><pre class=" language-text"><code class="language-text">ETCD_SERVER="--etcd-servers=http://127.0.0.1:2379"INSECURE_BIND_ADDRESS="--insecure-bind-address=0.0.0.0"INSECURE_PORT="--insecure-port=8080"SECURE_PORT="--secure-port=6443"SERVICE_CLUSTER_IP_RANGE="--service-cluster-ip-range=169.169.0.0/16"SERVICE_NODE_PORT_RANGE="--service-node-port-range=1-65535"ADMISSION_CONTROL="--admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota"LOGTOSTDERR="--logtostderr=false"LOGDIR="--log-dir=/var/log/kubernetes"LOG_LEVEL="--v=4"CLIENT_CA_FILE="--client-ca-file=/etc/kubernetes/ca.crt"TLS_PRIVATE_KEY="--tls-private-key=/etc/kubernetes/server.key"TLS_CERT_FILE="--tls-cert-file=/etc/kubernetes/server.crt"KUBE_API_ARGS=""</code></pre><p><em>kube-api.service:</em></p><pre class=" language-text"><code class="language-text">[Unit]Description=kube api serverAfter=etcd.serviceRequires=etcd.service[Service]EnvironmentFile=/etc/kubernetes/apiserverExecStart=/usr/bin/kube-apiserver \          $ETCD_SERVER \          $INSECURE_BIND_ADDRESS \          $INSECURE_PORT \          $SECURE_PORT \          $SERVICE_CLUSTER_IP_RANGE \          $SERVICE_NODE_PORT_RANGE \          $ADMISSION_CONTROL \          $LOGTOSTDERR \          $LOGDIR \          $LOG_LEVEL \          $CLIENT_CA_FILE \          $TLS_PRIVATE_KEY \          $TLS_CERT_FILE \          $KUBE_API_ARGSRestart=on=failureType=notifyLimitNOFILE=65535[Install]WantedBy=multi-user.target</code></pre><h3 id="kube-controller-manager配置"><a href="#kube-controller-manager配置" class="headerlink" title="kube-controller-manager配置"></a>kube-controller-manager配置</h3><p>由于是双向认证，所以对kube-controller-manager这个客户端来说，也需要生成对应的公私钥，而公钥需要被服务端识别则通过CA证书</p><pre class=" language-shell"><code class="language-shell">openssl genrsa -out cs_client.key 2048openssl req -new -key cs_client.key -subj "/CN=k8s-master" -out cs_client.csropenssl x509 -req -in cs_client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 5000 -out cs_client.crt</code></pre><p>在kube-controller-manager需要调用的配置文件中，也需要指定client-certificate, client-key, certificate-authority</p><p><em>kube-controller-manager.yaml:</em></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Config<span class="token key atrule">users</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> controllermanager  <span class="token key atrule">user</span><span class="token punctuation">:</span>    <span class="token key atrule">client-certificate</span><span class="token punctuation">:</span> /etc/kubernetes/ssl/cs_client.crt    <span class="token key atrule">client-key</span><span class="token punctuation">:</span> /etc/kubernetes/ssl/cs_client.key  <span class="token key atrule">clusters</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> local    <span class="token key atrule">cluster</span><span class="token punctuation">:</span>      <span class="token key atrule">certificate-authority</span><span class="token punctuation">:</span> /etc/kubernetes/ssl/ca.crt<span class="token key atrule">contexts</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">context</span><span class="token punctuation">:</span>    <span class="token key atrule">cluster</span><span class="token punctuation">:</span> local    <span class="token key atrule">user</span><span class="token punctuation">:</span> controllermanager  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>context<span class="token key atrule">current-context</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>context</code></pre><p>在连接API Server时，由于证书中Comman Name用的是hostname，所以在连接时也需要用hostname来连接</p><pre class=" language-text"><code class="language-text">API_MASTER="--master=https://k8s-master:6443"LOGTOSTDERR="--logtostderr=false"LOGDIR="--log-dir=/var/log/kubernetes"LOG_LEVEL="--v=4"SERVICE_ACCOUNT_KEY_FILE="--service-account-private-key-file=/etc/kubernetes/ssl/server.key"ROOT_CA_FILE="--root-ca-file=/etc/kubernetes/ssl/ca.crt"KUBECONFIG="--kubeconfig=/etc/kubernetes/kubeconfig"KUBE_CONTROLLER_MANAGER_ARGS=""</code></pre><p><em>kube-controller-manager.service:</em></p><pre class=" language-text"><code class="language-text">[Unit]Description=kube controller managerAfter=kube-apiserver.serviceRequires=kube-apiserver.service[Service]EnvironmentFile=/etc/kubernetes/controller-managerExecStart=/usr/bin/kube-controller-manager \          $API_MASTER \          $LOGTOSTDERR \          $LOGDIR \          $LOG_LEVEL \          $SERVICE_ACCOUNT_KEY_FILE \          $ROOT_CA_FILE \          $KUBECONFIG \          $KUBE_CONTROLLER_MANAGER_ARGSRestart=on=failureLimitNOFILE=65536[Install]WantedBy=multi-user.target</code></pre><h3 id="kube-scheduler配置"><a href="#kube-scheduler配置" class="headerlink" title="kube-scheduler配置"></a>kube-scheduler配置</h3><p>kube-scheduler用到的客户端证书及kubeconfig配置文件，和kube-controller-manager用到的是一致的，所以直接沿用即可</p><pre class=" language-text"><code class="language-text">API_MASTER="--master=https://k8s-master:6443"LOGTOSTDERR="--logtostderr=false"LOGDIR="--log-dir=/var/log/kubernetes"LOG_LEVEL="--v=4"KUBECONFIG="--kubeconfig=/etc/kubernetes/kubeconfig"KUBE_SCHEDULER_ARGS=""</code></pre><p><em>kube-scheduler:</em></p><pre class=" language-text"><code class="language-text">[Unit]Description=kube schedulerAfter=kube-apiserver.serviceRequires=kube-apiserver.service[Service]EnvironmentFile=/etc/kubernetes/schedulerExecStart=/usr/bin/kube-scheduler \          $API_MASTER \          $LOGTOSTDERR \          $LOGDIR \          $LOG_LEVEL \          $KUBECONFIG \          $KUBE_SCHEDULER_ARGSRestart=on=failureLimitNOFILE=65536[Install]WantedBy=multi-user.target</code></pre><h2 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h2><h3 id="kubelet配置"><a href="#kubelet配置" class="headerlink" title="kubelet配置"></a>kubelet配置</h3><p>Node节点中的CA证书需要和Master节点上的一致，所以需要将CA证书从Master节点复制到Node节点。同样，CA证书在Node节点上也需要安装</p><pre class=" language-shell"><code class="language-shell">yum install ca-certificates -yupdate-ca-trust force-enablecp ca.crt /etc/pki/ca-trust/source/anchors/update-ca-trust extract</code></pre><p>然后在生成Node节点需要用于认证和加密的公私钥</p><pre class=" language-shell"><code class="language-shell">openssl genrsa -out kubelet_client.key 2048openssl req -new -key kubelet_client.key -subj "/CN=k8s-master" -out kubelet_client.csropenssl x509 -req -in kubelet_client.csr  -CA ca.crt -CAkey ca.key -CAcreateserial -out kubelet_client.crt -days 5000</code></pre><p>通过kubeconfig来指定CA证书的路径及使用的公私钥和API Server的地址</p><pre class=" language-text"><code class="language-text">apiVersion: v1users:- name: kubelet  user:    client-certificate: /etc/kubernetes/ssl/kubelet_client.crt    client-key: /etc/kubernetes/ssl/kubelet_client.keyclusters:- cluster:    certificate-authority: ssl/ca.crt    server: https://k8s-master:6443  name: localcontexts:- context:    cluster: local    user: kubelet  name: my-contextcurrent-context: my-contextkind: Configpreferences: {}</code></pre><pre class=" language-text"><code class="language-text">ADDRESS="--address=10.0.83.63"HOSTNAME_OVERRIDE="--hostname-override=10.0.83.63"LOGTOSTDERR="--logtostderr=false"LOGDIR="--log-dir=/var/log/kubernetes"LOG_LEVEL="--v=5"KUBECONFIG="--kubeconfig=/etc/kubernetes/kubeconfig"KUBELET_ARGS='--cloud-provider=""'</code></pre><p><em>kubelet.service:</em></p><pre class=" language-text"><code class="language-text">[Unit]Description=kubelet serverAfter=docker.serviceRequires=docker.service[Service]WorkingDirectory=/var/lib/kubeletEnvironmentFile=/etc/kubernetes/kubeletExecStart=/usr/bin/kubelet \          $HOSTNAME_OVERRIDE \          $LOGTOSTDERR \          $LOGDIR \          $LOG_LEVEL \          $KUBECONFIG \          $KUBELET_ARGSRestart=on=failure[Install]WantedBy=multi-user.target</code></pre><h3 id="kube-proxy配置"><a href="#kube-proxy配置" class="headerlink" title="kube-proxy配置"></a>kube-proxy配置</h3><p>同样，kube-proxy的CA证书及公私钥和kubelet使用的一致，所以直接沿用</p><pre class=" language-text"><code class="language-text">API_MASTER="--master=https://k8s-master:6443"LOGTOSTDERR="--logtostderr=false"LOGDIR="--log-dir=/var/log/kubernetes"LOG_LEVEL="--v=4"KUBECONFIG="--kubeconfig=/etc/kubernetes/kubeconfig"KUBE_PROXY_ARGS=""</code></pre><pre class=" language-text"><code class="language-text">[Unit]Description=kubelet proxyAfter=network.targetRequires=network.service[Service]EnvironmentFile=/etc/kubernetes/proxyExecStart=/usr/bin/kube-proxy \          $API_MASTER \          $LOGTOSTDERR \          $LOGDIR \          $LOG_LEVEL \          $KUBECONFIG \          $KUBE_PROXY_ARGSRestart=on=failureLimitNOFILE=65535[Install]WantedBy=multi-user.target</code></pre>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pod升级和回滚</title>
      <link href="/2022/06/05/middleware/kubernetes/Pod%E5%8D%87%E7%BA%A7%E5%92%8C%E5%9B%9E%E6%BB%9A/"/>
      <url>/2022/06/05/middleware/kubernetes/Pod%E5%8D%87%E7%BA%A7%E5%92%8C%E5%9B%9E%E6%BB%9A/</url>
      
        <content type="html"><![CDATA[<p>当集群的某个服务需要升级时，需要停止目前与该服务相关的所有Pod，然后再下载或导入新版本镜像并创建新的Pod，如果集群的规模比较大，整个升级就会变得异常痛苦，在升级的过程中会导致较长时间的服务不可用的状态。所以Kubernetes提供了滚动升级功能来解决上述问题。</p><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>通过Deployment创建的Pod，可以在运行时修改Deployment的Pod定义（spec:template）或镜像名称，并应用到Deployment对象上，系统即可完成Deployment的自动更新操作。如果在更新的过程中发生错误，还可以通过回滚来恢复Pod的版本。</p><p>现有一个Deployment文件，可以看到其中镜像使用的版本是nginx 1.14.0</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> frontend                                         <span class="token comment" spellcheck="true">#Deployment对象的名称</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3                                            </span><span class="token comment" spellcheck="true">#生成的副本数量</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">tier</span><span class="token punctuation">:</span> frontend                                     <span class="token comment" spellcheck="true">#选择器选择的标签，匹配副本的Label字段</span>    <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token punctuation">{</span><span class="token key atrule">key</span><span class="token punctuation">:</span> tier<span class="token punctuation">,</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> In<span class="token punctuation">,</span> <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>frontend<span class="token punctuation">]</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">#Key-Value形式对标签进行匹配</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">tier</span><span class="token punctuation">:</span> frontend                                   <span class="token comment" spellcheck="true">#副本所打上的标签</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.io/nginx<span class="token punctuation">:</span>1.14.0                    <span class="token comment" spellcheck="true">#Pod所使用的镜像</span>        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80                              </span><span class="token comment" spellcheck="true">#容器所暴露的端口</span></code></pre><p>然后创建一个Deployment资源对象，可以看到Deployment对象创建成功</p><p><a href="https://imgtu.com/i/Xw8BB4"><img src="https://s1.ax1x.com/2022/06/05/Xw8BB4.png" alt="1.png"></a></p><p>通过kubelet describe可以查看创建生成的Pod的具体信息，可以看到所使用的image是nginx 1.14.0</p><p><a href="https://imgtu.com/i/Xw8DHJ"><img src="https://s1.ax1x.com/2022/06/05/Xw8DHJ.png" alt="2.png"></a></p><p>通过手动调用kubelet去修改Deployment对象的镜像版本号，使用最新版本的nginx，可以看到Deployment对象已经更新</p><p><a href="https://imgtu.com/i/Xw8sE9"><img src="https://s1.ax1x.com/2022/06/05/Xw8sE9.png" alt="3.png"></a></p><p>查看Pod的详细信息，发现当前的Pod已经使用的是最新版本的nginx</p><p><a href="https://imgtu.com/i/Xw8641"><img src="https://s1.ax1x.com/2022/06/05/Xw8641.png" alt="4.png"></a></p><p>通过调用<code>kubectl describe deployment</code>，可以看到Deployment对象的详细事件信息。</p><p>从中可以看到初始化的时候（创建Deployment对象时），kubelet创建了一个ReplicasSet frontend-4271948474并将副本数设置为3。6分钟之后触发手动更新操作，kubelet新创建了一个ReplicasSet frontend-4066361464并将其副本数量设置为1，然后将之前的ReplicasSet frontend-4271948474的数量设置为2，从而保证副本数量始终保持在期望值之中，并保证业务不会中断。之后慢慢的将旧的副本数降低至0，新的副本数增加至3完成滚动更新。</p><p><a href="https://imgtu.com/i/Xw8g9x"><img src="https://s1.ax1x.com/2022/06/05/Xw8g9x.png" alt="5.png"></a></p><p>整个滚动更新的流程如下图</p><p><a href="https://imgtu.com/i/Xw8236"><img src="https://s1.ax1x.com/2022/06/05/Xw8236.png" alt="6.png"></a></p><p>在整个滚动升级的过程中，系统会保证至少有2个Pod可用，并且最多可以同时运行4个Pod，在默认情况下，Deployment确保可用的Pod总数至少为所需的副本数量减maxUnavailable的数量，而Pod总数最多也不会超过maxSurge。maxUnavailable和maxSurge可以在Deployment对象的yaml文件中进行调节，之前的版本默认为1，从1.6版本之后，默认值更改为25%。</p><ul><li>maxUnavailable: 用于指定Deployment在更新过程中不可用的状态的Pod数量上限，该值可以是数值的绝对值也可以是Pod期望值数量的百分比</li><li>maxSurge: 用于指定Deployment更新Pod过程中Pod总数超过Pod期望值的最大值。该值可以是数值的绝对值也可以是Pod期望值数量的百分比</li></ul><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>当进行更新的版本不稳定时，我们可能要回滚到上一版本。默认情况下，所有的Deployment发布的历史记录都存在于系统中，以便我们随时可以进行回滚。</p><p>通过调用<code>kubectl rollout history deployment</code>可以查看Deployment的部署记录，加上–revision参数可以看到具体版本的信息。</p><p><a href="https://imgtu.com/i/Xw8RgK"><img src="https://s1.ax1x.com/2022/06/05/Xw8RgK.png" alt="7.png"></a></p><p>如果我们想要回滚到第一个版本，可以看到和滚动更新一样，会把旧的ReplicasSet创建的Pod减少，新的ReplicasSet创建的Pod增加。</p><p><a href="https://imgtu.com/i/Xw8huD"><img src="https://s1.ax1x.com/2022/06/05/Xw8huD.png" alt="8.png"></a></p><p>通过查看Pod的详细信息可以看到确实Pod的版本已经回滚到上一版本</p><p><a href="https://imgtu.com/i/Xw84De"><img src="https://s1.ax1x.com/2022/06/05/Xw84De.png" alt="9.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pod扩容缩容</title>
      <link href="/2022/06/05/middleware/kubernetes/Pod%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9/"/>
      <url>/2022/06/05/middleware/kubernetes/Pod%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>由于在实际的环境里，很多服务可能会面临由于业务扩展，原来的服务处理能力不够或者面临突发性的大量访问的场景，这就需要对现有的业务进行扩容。也有可能由于资源紧张或者架构调整负载降低等场景，需要对现有业务进行缩容。面对这些场景可以使用Deployment&#x2F;RC的Scale机制来处理。</p><p>Kubernetes对Pod的扩缩容提供了两种模式，手动和自动扩缩容。手动模式是通过手动调用kubectl scale命令对一个Deployment&#x2F;RC的Pod来进行副本的设置。自动模式是通过用户指定的某个性能指标或者自定义业务指标的策略来对Pod数量进行调整。</p><h2 id="手动扩缩容"><a href="#手动扩缩容" class="headerlink" title="手动扩缩容"></a>手动扩缩容</h2><p>在有的场景中，需要预先对业务服务进行扩缩容，而当前的系统资源并未达到可以自动扩缩容的状态，这个时候就只能通过手动模式来进行。</p><p>以下是Deployment对象的配置文件，可以通过该文件创建一个Deployment对象，在该文件中创建的Pod副本数为3</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> extensions/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> frontend                                         <span class="token comment" spellcheck="true">#Deployment对象的名称</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3                                            </span><span class="token comment" spellcheck="true">#生成的副本数量</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">tier</span><span class="token punctuation">:</span> frontend                                     <span class="token comment" spellcheck="true">#选择器选择的标签，匹配副本的Label字段</span>    <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token punctuation">{</span><span class="token key atrule">key</span><span class="token punctuation">:</span> tier<span class="token punctuation">,</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> In<span class="token punctuation">,</span> <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>frontend<span class="token punctuation">]</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">#Key-Value形式对标签进行匹配</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">tier</span><span class="token punctuation">:</span> frontend                                   <span class="token comment" spellcheck="true">#副本所打上的标签</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx          <span class="token key atrule">image</span><span class="token punctuation">:</span> docker.io/nginx<span class="token punctuation">:</span>1.14.0                    <span class="token comment" spellcheck="true">#Pod所使用的镜像</span>          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80                              </span><span class="token comment" spellcheck="true">#容器所暴露的端口</span></code></pre><p>通过使用kubectl create -f nginx-deploy.yaml来创建一个Deployment对象</p><p><a href="https://imgtu.com/i/Xw8pp6"><img src="https://s1.ax1x.com/2022/06/05/Xw8pp6.png" alt="terminal-1.png"></a></p><p>假如现在需要对Pod进行扩容，可以手动调用kubectl scale deployment frontend –replicas 5来扩容，将副本数量增加到5个</p><p><a href="https://imgtu.com/i/Xw8Fne"><img src="https://s1.ax1x.com/2022/06/05/Xw8Fne.png" alt="terminal-2.png"></a></p><p>如果需要缩容，将replicas的值减少即可</p><h2 id="自动扩缩容"><a href="#自动扩缩容" class="headerlink" title="自动扩缩容"></a>自动扩缩容</h2><p>从Kubernetes 1.1版本开始，就新增了Horizontal Pod AutoScaler(HPA)的控制器，用于实现基于CPU使用率来进行自动Pod扩缩容的功能。HPA控制器基于Master的kube-controller-manager服务启动参数–horizontal-pod-autoscaler-sync-period定义的时长（默认30s）来周期性的监测目标Pod的CPU使用率，并在满足条件的时候对RC&#x2F;Deployment的副本数量进行调整，以符合用户定义的平均Pod CPU的使用率。需要安装Heapster。</p><p>更多关于HPA的说明可以参考<a href="https://blog.f4ct0r.top/2022/06/05/middleware/kubernetes/Kubernetes%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90/">Kubernetes概念解释</a></p>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pod的生命周期、重启策略和健康检查</title>
      <link href="/2022/06/05/middleware/kubernetes/Pod%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5%E5%92%8C%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
      <url>/2022/06/05/middleware/kubernetes/Pod%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5%E5%92%8C%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Pod的生命周期"><a href="#Pod的生命周期" class="headerlink" title="Pod的生命周期"></a>Pod的生命周期</h2><p>Pod在整个生命周期过程中被定义为各种状态：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>Pending</td><td>API Server已经创建该Pod，但Pod内还有一个或多个容器的镜像没有创建，包括正在下载的镜像的过程</td></tr><tr><td>Running</td><td>Pod内的所有容器都已经创建，且至少有一个容器处于运行、正在启动或正在重启的状态</td></tr><tr><td>Succeeded</td><td>Pod内所有容器均成功执行退出，且不会重启</td></tr><tr><td>Failed</td><td>Pod内所有容器均已退出，且至少有一个容器退出的状态为失败状态</td></tr><tr><td>Unknown</td><td>由于某种原因无法获取到该Pod的状态</td></tr></tbody></table><h2 id="Pod的重启策略"><a href="#Pod的重启策略" class="headerlink" title="Pod的重启策略"></a>Pod的重启策略</h2><p>Pod的重启策略顾名思义是应用于Pod内的所有容器，并且仅在Pod所处的Node上由kubelet根据RestartPolicy进行判断和重启操作。</p><p>Pod的重启策略包括：</p><ul><li>Always: 当容器失效时，由kubelet自动重启该容器</li><li>OnFailure: 当容器终止运行且退出码不为0时，由kubelet自动重启该容器</li><li>Never: 不论容器运行状态如何，kubelet都不会重启该容器</li></ul><p>kubelet重启失效容器的时间间隔以sync-frequency * 2n来计算，最长延时5分钟，并在重启成功后重置该时间。</p><p>用于管理Pod的资源对象RC、Job、DaemonSet及直接调用kubelet管理对重启策略都存在不同的要求：</p><ul><li>RC和DaemonSet: 必须设置为Always，需要保证该容器持续运行</li><li>Job: 偏向于一次性任务，一般设置为OnFailure或Never，确保容器在执行完成后不再重启</li><li>kubelet: 在Pod失效时自动重启它，不论RestartPolicy设置什么值，也不会对Pod进行健康检查</li></ul><h2 id="Pod健康检查"><a href="#Pod健康检查" class="headerlink" title="Pod健康检查"></a>Pod健康检查</h2><p>Pod的健康检查可以通过两种探针来检查：</p><ul><li>LivenessProbe: 判断容器是否存活（Running状态），如果LivenessProbe探针发现容器不健康，kubelet会kill掉该容器并根据RestartPolicy做相应处理。如果一个容器不包含LivenessProbe探针，那么kubelet会认为该容器的LivenessProbe探针永远返回Success。LivenessProbe探针有三种实现方式：</li><li>ExecAction: 在容器内部执行一条shell命令，如果该命令的返回值是0，则表明容器健康</li><li>TCPSocketAction: 通过容器的IP地址和端口进行TCP连接，如果连接成功则表明容器健康</li><li>HTTPGetAction: 通过容器的IP地址、端口和路径调用HTTP GET请求，如果相应码&gt;200且&lt;400，则认为容器健康</li><li>ReadinessProbe: 判断容器是否启动完成（Ready状态），可以接受请求，如果ReadinessProbe探针检测到失败，Pod状态会被修改。EndpointController将从Service的Endpoint中删除包含该容器所在Pod的EndPoint。</li></ul><p>对于每种探测方式，都需要设置以下两个参数：</p><ul><li>initialDelaySeconds: 启动容器后进行首次检查的等待时间，单位为s</li><li>timeoutSeconds: 健康检查请求发起后等待的超时时间，单位为s，如果发生超时，kubelet会认为容器无法再提供服务，会对Pod进行重启</li></ul>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes介绍</title>
      <link href="/2022/06/05/middleware/kubernetes/Kubernetes%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/06/05/middleware/kubernetes/Kubernetes%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes是什么"><a href="#Kubernetes是什么" class="headerlink" title="Kubernetes是什么"></a>Kubernetes是什么</h2><p>首先，Kubernetes是一个全新的基于容器的分布式架构解决方案。这个解决方案由Google在2014年进行开源，是<a href="https://research.google/pubs/pub43438/">Google Brog</a>（Brog是Google内部使用的基于容器的大规模集群管理系统）的开源版本。通过采用Kubernetes的设计架构，我们可以将很多底层分布式处理的工作交给Kubernetes，如负载均衡，服务调度，集群监控等，我们可以更专注于业务本身。</p><p>其次，Kubernetes是一个开放的平台，它可以适用于任何一种平台（Windows，Linux，MACOS，BSD等），并且可以支持任何语言编写的服务，通过标准的TCP&#x2F;IP协议进行交互。</p><p>最后，Kubernetes是一个完备的分布式系统支撑平台，拥有完备的集群管理能力，包括多层次的安全防护与准入控制，多租户应用支撑能力，透明的服务注册和服务发现机制，内建负载均衡，并拥有强大的故障发现及自我修复能力、服务滚动升级和在线扩容能力。</p><h2 id="Kubernetes能干什么"><a href="#Kubernetes能干什么" class="headerlink" title="Kubernetes能干什么"></a>Kubernetes能干什么</h2><p>Kubernetes拥有以下几个特性：</p><ul><li>容器平台</li><li>微服务平台</li><li>便携的云平台</li></ul><p>首先，Kubernetes提供了一个容器中心管理环境，它可以对计算资源、网络资源、存储资源进行编排。</p><p>其次，通过Kubernetes底层的分布式能力，原来需要开发的分布式的服务调度，集群监控，服务发现等功能现在可以通通交给Kubernetes，可以让程序更专于业务本身。</p><p>然后，Kubernetes非常适合微服务架构，微服务架构的核心就是将一个庞大的单体应用拆分成无数个微小的相互联系的服务，一个微服务背后可能由多个副本来保证高可用及负载均衡，副本数量可能会随着系统资源动态进行调节。每个服务都可以由不同的开发团队选择不同的技术来进行实现，每个服务也可以独立进行升级扩展，让整个系统拥有更强的稳定性。</p><p>最后，Kubernetes具有强大的横向扩缩容能力，通过对系统资源的监测及用户配置来决定是否对副本进行扩缩容，通过负载均衡器或者无中心化的集群，在进行扩缩容时对用户完全透明，让业务系统长期都由良好的稳定性。</p><h2 id="Kubernetes没有做什么"><a href="#Kubernetes没有做什么" class="headerlink" title="Kubernetes没有做什么"></a>Kubernetes没有做什么</h2><p>Kubernetes并不是一个传统的包罗万象的PaaS平台，因为Kubernetes操作在容器层而不是物理层，它提供了一些PaaS的通用特性，如部署、扩容、负载均衡、监控、日志记录等。但是，Kubernetes的这些特性并不是固定的，而是可选可插拔的。</p><p>Kubernetes没有做什么：</p><ul><li>没有限制支持的应用的种类，Kubernetes旨在支持各种各样的应用，包括无状态、有状态、数据处理的应用，只要应用可以在容器中运行，就可以完美的在Kubernetes中跑起来。</li><li>不对源码或者应用程序进行部署，可以根据技术需求来决定构建怎么样的CI&#x2F;CD流程。</li><li>不直接提供应用级的服务，如中间件、数据处理框架，数据库，缓存或者是集群化的存储方案，但是这些组件都可以运行在Kubernetes中，也可以被其他运行在Kubernetes中的应用进行访问。</li><li>不提供日志与监控的解决方案，仅仅提供一些插件和机制来收集和导出这些指标。</li><li>不提供配置语言，它提供了一个声明性API，可以通过任意形式的声明性规范来实现。</li><li>不提供或采用任何全面的机器配置，维护，管理或自我修复系统。</li></ul><h2 id="为什么选择容器"><a href="#为什么选择容器" class="headerlink" title="为什么选择容器"></a>为什么选择容器</h2><p>之前部署应用是通过在目标机器上通过包管理工具进行安装，这就导致在系统中的各种应用的运行，配置，库依赖和生命周期都不能很好的解耦（例如两个应用程序所需要的依赖库相同或仅版本不同），也有通过利用虚拟机镜像进行部署和回滚，但是虚拟机的重量的移植性不高，原因在于每一个虚拟机镜像都是一个独立的系统，过多的应用会导致虚拟机镜像无限扩大。</p><p><a href="https://imgtu.com/i/Xw3Pds"><img src="https://s1.ax1x.com/2022/06/05/Xw3Pds.jpg" alt="kubernetes-1.jpg"></a></p><p>新的方案是通过基于操作系统级别的虚拟化技术来实现的容器化部署，而不是硬件层面的虚拟化技术。这些容器可以从Host层面上进行彼此隔离，它们都有自己的文件系统，彼此间无法看到对方的进程，并且可以对使用的系统的算资源进行限制。容器比虚拟机更方便构建部署，因为容器虽然使用同一个内核，但是底层基础架构和主机文件系统分离。</p><p><a href="https://imgtu.com/i/Xw3ion"><img src="https://s1.ax1x.com/2022/06/05/Xw3ion.jpg" alt="kubernetes-2.jpg"></a></p><p>由于容器更小，也可以更快进行构建，一个应用程序便可以被打包成一个容器镜像，而这种一对一的应用程序到映像关系解锁了容器的全部优势。通过使用容器，可以在代码构建发布时创建一个不可变的镜像，而不需要在部署时才开始进行环境的安装等操作，因为每一个镜像并需要依赖其他的应用程序，也不需要和基础环境相耦合。而且，容器比虚拟机更加透明，可以更好的实现对资源的监控和管理。</p><p><em>容器的优势</em>：</p><ul><li>更灵活的应用创建及部署：比虚拟机镜像更简易和高效的创建容器镜像。</li><li>持续性的开发，集成和部署：通过快速简便的回滚（由于镜像不变性）提供可靠且频繁的容器镜像构建和部署。</li><li>开发部署关注点分离：因为应用程序和基础设施的解耦性，可以在镜像的构建发布阶段而不是在部署阶段创建好应用容器的不可变镜像。</li><li>监控：不仅仅可以监控系统层面上的信息和指标，也可以对应用进行健康检查。</li><li>开发，测试和生产的环境一致性：开发环境和生产环境是保持一致的。</li><li>适应性：可以运行在任何地方，Ubuntu，RHEL，CoreOS，Google Kubernetes Engine等。</li><li>以应用为中心的管理方式：将应用作为运行在系统上的逻辑资源单元进行管理。</li><li>松耦合，分布式，微服务，弹性计算：应用程序被分解为更小的独立部分，可以动态部署和管理，而不是在一台大型单一用途机器上运行的庞大的整体堆栈。</li><li>资源隔离：对应用进行资源隔离，使得资源可以被分配在不同的应用上，从而性能可被预测。</li><li>资源利用：通过对资源的分配，可以更高效更合理的利用资源。</li></ul>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes概念解析</title>
      <link href="/2022/06/05/middleware/kubernetes/Kubernetes%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/06/05/middleware/kubernetes/Kubernetes%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker部分"><a href="#Docker部分" class="headerlink" title="Docker部分"></a>Docker部分</h2><h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><p>对于 Linux 而言，内核启动后，会挂载 root文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层都代表Dockerfile的指令集合，并且除最后一层外的每一层都是只读的。当创建一个新的容器时，实际上是在最上层增加了一个可写层，这一层通常被称作容器层，所有的变化都是在这一层上完成的。</p><p><a href="https://imgtu.com/i/Xwl91S"><img src="https://s1.ax1x.com/2022/06/05/Xwl91S.jpg" alt="docker-1.jpg"></a></p><h3 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h3><p>Docker容器和镜像最大的不同点就在于最上面的可写层，所有在容器中的写入操作如新增和修改已有的数据都被存储在这一层。当容器被删除时，这一层也会被删除，在这之下的镜像仍然是未改变状态。因为每一个容器都拥有自己的可写层，并且所有的写入操作都在这一层完成，所以多个容器可以复用同一个镜像。</p><p><a href="https://imgtu.com/i/XwlKcF"><img src="https://s1.ax1x.com/2022/06/05/XwlKcF.jpg" alt="docker-2.jpg"></a></p><h2 id="Kubernetes部分"><a href="#Kubernetes部分" class="headerlink" title="Kubernetes部分"></a>Kubernetes部分</h2><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>Master节点是Kubernetes集群的控制节点，每个Kubernetes集群里至少有一个Master节点，它负责整个集群的决策（如调度），发现和响应集群的事件。Master节点可以运行在集群中的任意一个节点上，但是最好将Master节点作为一个独立节点，不在该节点上创建容器，因为如果该节点出现问题导致宕机或不可用，整个集群的管理就会失效。</p><p>在Master节点上，通常会运行以下服务：</p><ul><li>kube-apiserver: 部署在Master上暴露Kubernetes API，是Kubernetes的控制面。</li><li>etcd: 一致且高度可用的Key-Value存储，用作Kubernetes的所有群集数据的后备存储。</li><li>kube-scheduler: 调度器，运行在Master上，用于监控节点中的容器运行情况，并挑选节点来创建新的容器。调度决策所考虑的因素包括资源需求，硬件&#x2F;软件&#x2F;策略约束，亲和和排斥性规范，数据位置，工作负载间干扰和最后期限。</li><li>kube-controller-manager: 控制和管理器，运行在Master上，每个控制器都是独立的进程，但为了降低复杂性，这些控制器都被编译成单一的二进制文件，并以单独的进程运行。<ul><li>Node Controller: 负责发现出现问题的Node，并作出响应。</li><li>Replication Controller: 负责将Pod的数量稳定在正确的数量上。</li><li>Endpoints Controller: 填充Endpoints对象。</li><li>Service Account &amp; Token Controllers: 负责在新的namespace中创建默认账户和API的访问Token</li></ul></li></ul><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node节点是Kubernetes集群的工作节点，每个Kubernetes集群中至少需要一台Node节点，它负责真正的运行Pod，当某个Node节点出现问题而导致宕机时，Master会自动将该节点上的Pod调度到其他节点。Node节点可以运行在物理机上，也可以运行在虚拟机中。</p><p>在Node节点上，通常会运行以下服务：</p><ul><li>kubelet: 运行在每一个Node节点上的客户端，负责Pod对应的容器创建，启动和停止等任务，同时和Master节点进行通信，实现集群管理的基本功能。</li><li>kube-proxy: 负责Kubernetes Services的通信和负载均衡机制。</li><li>Docker Engine: 负责节点上的容器的创建和管理。</li></ul><p>Node节点可以在集群运行期间动态增加，只要整个节点已经正确安装配置和启动了上面的进程。在默认情况下，kubelet会向Master自动注册。一旦Node被接入到集群管理中，kubelet会定时向Master节点汇报自身的情况（操作系统，Docker版本，CPU内存使用情况等），这样Master便可以在知道每个节点的详细情况的同时，还能知道该节点是否是正常运行。当Node节点心跳超时时，Master节点会自动判断该节点处于不可用状态，并会对该Node节点上的Pod进行迁移。</p><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>Kubernetes中的Label和Dockerfile中的Label不太一样，Dockerfile中的Label为Key-Value键值对，键是字母数字字符串，可以包含.和-字符，Label很大程度上可以用作自动化项目上，例如maintainer&#x3D;”f4ct0r<a href="mailto:&#x61;&#x64;&#x6d;&#x69;&#x6e;&#x40;&#x66;&#x34;&#99;&#116;&#x30;&#114;&#46;&#x74;&#x6f;&#x70;">&#x61;&#x64;&#x6d;&#x69;&#x6e;&#x40;&#x66;&#x34;&#99;&#116;&#x30;&#114;&#46;&#x74;&#x6f;&#x70;</a>“。</p><p>而在Kubernetes中，Label虽然也是Key-Value键值对，但是Label可以附加在各种资源对象上，例如Node、Pod、Service等。Label旨在标示对象对用户的特殊意义（如”release”: “dev”）。通过对给定的资源对象打上Label，可以实现多维度的资源分组管理，以便更灵活的进行资源分配，调度，配置和部署等工作。</p><p>通过Label Selector可以很简单的对资源对象进行筛选，如kube-controller通过资源对象RC上定义的Label Selector来筛选要监控的Pod副本数量，从而使Pod数量始终保持在一个稳定值。</p><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod是Kubernetes最重要也是最基本的概念，一个Pod是一组可以共享网络和存储（可以是一个或多个）的容器。Pod中的容器都是统一进行调度，并且运行在共享上下文中。一个Pod被定义为一个逻辑的host，它包括一个或多个相对耦合的容器。</p><p>Pod的共享上下文，实际上是一组由namespace, cgroups, 其他资源的隔离的集合，意味着Pod中的资源已经是被隔离过了的，而在Pod中的每一个独立的container又对Pod中的资源进行了二次隔离。</p><p><a href="https://imgtu.com/i/Xwlk0s"><img src="https://s1.ax1x.com/2022/06/05/Xwlk0s.jpg" alt="kubernetes-1.jpg"></a></p><p>Pod中的容器共享一个IP地址和端口资源，它们可以通过localhost进行通信，根据需要，这些容器间也可以通过标准的进程间通信（系统层面的信号量）或POSIX共享内存进行数据交换。在不同Pod间的容器进行通信时，只能通过Pod IP。相同Pod中的不同容器可以通过挂载相同的Volume的形式来实现共享卷。<br>Pod有两种类型，普通Pod和静态Pod(Staic Pod)：</p><ul><li>普通Pod：一旦被创建，会被放在etcd中进行存储，随后会被Master调度到某个Node上绑定，随后该Pod中对应的Node上的kubelet进程会实例化一组Docker容器并启动。默认情况下，当Pod中的某个容器停止时，Kubernetes会自动监测并重启整个Pod。</li><li>静态Pod：不会存储在etcd中，而是放在某个具体的Node上的具体文件中，并且只在这个Node上启动运行。</li></ul><p><a href="https://imgtu.com/i/XwlFmj"><img src="https://s1.ax1x.com/2022/06/05/XwlFmj.jpg" alt="XwlFmj.jpg"></a></p><h3 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h3><p>ReplicationController(RC)其实是定义了一个期望的场景，保证Pod的副本数量在任意时刻都符合某个预期值，所以RC的定义包括以下几个部分：</p><ul><li>预期Pod的副本数量</li><li>用于筛选目标的Label Selector</li><li>当Pod数量少于预期数量时，用于创建Pod的template</li></ul><p>如果Pod的数量过多，RC会停止多余的Pod，如果Pod数量太少，RC会创建更多的Pod来满足期望值。当RC创建的Pod出现异常导致失败的情况下，RC会自动删除失败的Pod并重新创建新的Pod来替换失败的Pod，一个RC就类似于supervisor，不同的在于supervisor管理的是单一进程，而且RC管理的是一个Pod。<br>需要注意的是，删除RC并不会删除已经创建好的Pod，为了删除Pod可以将replicas设置为0后再删除RC，或使用kubelet提供的stop和delete命令来删除Pod。</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment是ReplicationController的升级版本，Deployment控制器会根据在Deployment对象中描述的期望状态对Pod进行调整。通过Deployment控制器，我们可以随时了解Pod部署的进度，因为实际上Pod的创建、调度、绑定等操作都是需要时间的。</p><p>Deployment典型应用场景：</p><ul><li>创建Deployment对象来生产对应的ReplicaSet来完成部署</li><li>通过更新Deployment的PodTemplateSpec更新Pod的最新状态。更新时，新的RelicaSet会被创建，Deployment控制器会将老的ReplicaSet中的Pod以一定的速率迁移到新的ReplicaSet中。</li><li>回滚到早期版本</li><li>扩展Deployment以应对高负载</li><li>暂停Deployment以便一次性修改多个PodTemplateSpec的配置项，之后再恢复Deployment进行新的发布</li><li>查看Deployment状态来作为发布是否成功的标准</li><li>清理不需要的ReplicaSet</li></ul><h3 id="Horizontal-Pod-Autoscaler"><a href="#Horizontal-Pod-Autoscaler" class="headerlink" title="Horizontal Pod Autoscaler"></a>Horizontal Pod Autoscaler</h3><p>虽然可以通过手动执行kubelet scale命令对Pod进行扩容，但是这始终需要人工参与无法做到完全自动化，所以Google推出了Horizontal Pod Autoscaler(HPA)来实现动态扩容。HPA和RC、Deployment一样，也是一种资源对象。它可以通过分析RC控制的所有Pod的负载的变化，来确定是否需要对Pod数量进行调整。<br>HPA可以通过以下两种指标来作为度量指标：</p><ul><li>CPU使用率</li><li>应用程序自定义的度量指标，如服务每秒的请求数</li></ul><p><a href="https://imgtu.com/i/XwlPXQ"><img src="https://s1.ax1x.com/2022/06/05/XwlPXQ.jpg" alt="kubernetes-3.jpg"></a></p><p>HPA的实现类似于一个定时任务，在一定的时间间隔（默认是30s）由–horizontal-pod-autoscaler-sync-period flag控制，每经过一个时间间隔，控制器就会在每个HPA中通过API来查询Pod使用的资源情况。当指标使用百分率时，控制器将会对Pod中容器使用的资源进行百分比计算，来判断是否需要进行扩容；如果指标使用原始值，那么控制器就会以该值作为是否需要扩容的阈值。</p><h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><p>在Kubernetes中，Pod的很多管理对象如RC、Deployment、DaemonSet和Job都是面向无状态服务的（如nginx，tomcat），但实际上很多服务是有状态的（如Mysql，Mongo），这些服务或服务集群都有以下的共同点：</p><ul><li>每个节点都有固定的身份ID，通过这个ID，集群中的成员可以相互发现并通信。</li><li>集群规模相对固定，不会经常变动。</li><li>节点是有状态的，并会将数据持久化写入存储中。</li><li>当磁盘损坏，可能会导致集群不可用。</li></ul><p>如果使用面向无状态服务的管理对象来创建Pod，我们会发现Pod的名字是在Pod创建好之后才会进行生成，并且为了保证唯一性会加入随机字符串，导致名称无法预测。而Pod IP也是在Pod创建之后才会生成，也无法事先获取。这样就会导致有服务状态的集群无法添加成员。所以为了解决这个问题，增加了一个特殊的管理对象StatefulSet，这个对象有如下特性：</p><ul><li>稳定独特的网络标示</li><li>稳定持久化的存储</li><li>有序优雅的部署和扩容</li><li>有序优雅的删除和停止</li><li>有序自动化的更新</li></ul><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Kubernetes Service 定义了这样一种抽象：一个 Pod 的逻辑分组，一种可以访问它们的策略，通常称为微服务。 这一组Pod能够被Service访问到，通常是通过Label Selector实现的。</p><p>举个例子，考虑一个图片处理 backend，它运行了3个副本，这些副本是可互换的，frontend 不需要关心它们调用了哪个 backend 副本。 然而组成这一组 backend 程序的 Pod 实际上可能会发生变化，frontend 客户端不应该也没必要知道，而且也不需要跟踪这一组 backend 的状态。 Service 定义的抽象能够解耦这种关联。</p><p>对 Kubernetes 集群中的应用，Kubernetes 提供了简单的 Endpoints API，只要 Service 中的一组 Pod 发生变更，应用程序就会被更新。 对非 Kubernetes 集群中的应用，Kubernetes 提供了基于 VIP 的网桥的方式访问 Service，再由 Service 重定向到 backend Pod。</p><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题。首先，当容器崩溃时，kubelet 会重启它，但是容器中的文件将丢失——容器以干净的状态（镜像最初的状态）重新启动。其次，在 Pod 中同时运行多个容器时，这些容器之间通常需要共享文件。Kubernetes 中的 Volume 抽象就很好的解决了这些问题。</p><p>Docker 中也有一个 volume 的概念，尽管它稍微宽松一些，管理也很少。在 Docker 中，卷就像是磁盘或是另一个容器中的一个目录。它的生命周期不受管理，直到最近才有了 local-disk-backed 卷。Docker 现在提供了卷驱动程序，但是功能还非常有限（例如Docker1.7只允许每个容器使用一个卷驱动，并且无法给卷传递参数）。</p><p>另一方面，Kubernetes 中的卷有明确的寿命——与封装它的 Pod 相同。所以，卷的生命比 Pod 中的所有容器都长，当这个容器重启时数据仍然得以保存。当然，当 Pod 不再存在时，卷也将不复存在。也许更重要的是，Kubernetes 支持多种类型的卷（如GlusterFS, Ceph等分布式文件系统），Pod 可以同时使用任意数量的卷。</p><p>卷的核心是目录，可能还包含了一些数据，可以通过 pod 中的容器来访问。该目录是如何形成的、支持该目录的介质以及其内容取决于所使用的特定卷类型。要使用卷，需要为 pod 指定为卷（spec.volumes 字段）以及将它挂载到容器的位置（spec.containers.volumeMounts 字段）。</p><p>容器中的进程看到的是由其 Docker 镜像和卷组成的文件系统视图。 Docker 镜像位于文件系统层次结构的根目录，任何卷都被挂载在镜像的指定路径中。卷无法挂载到其他卷上或与其他卷有硬连接。Pod 中的每个容器都必须独立指定每个卷的挂载位置。</p><h3 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h3><p>在分布式环境下，很难做到让各种应用程序的端口都不一致，而动态端口分配也会有问题，例如像API服务使用动态端口会导致调用API的程序无法找到端口。所以Kubernetes采用了barring any intentional network segmentation policies来解决这些问题。</p><p>barring any intentional network segmentation policies:</p><ul><li>所有的容器在不通过NAT的情况下可以相互通信</li><li>所有的Node可以与所有的容器在不通过NAT的情况下进行通信</li><li>容器的IP内部和外部可见，并都保持一致</li></ul><p>实际上Kubernetes的IP地址是在Pod上的，在Pod中的容器共享同一个namespace，包括IP地址。这就意味着Pod中的容器可以通过localhost访问彼此，所以Pod中的容器只需要保证彼此间端口不冲突就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> middleware </category>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sonarqube检测流程及插件编写</title>
      <link href="/2022/06/05/security/snoarqube/sonarqube%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/"/>
      <url>/2022/06/05/security/snoarqube/sonarqube%E6%A3%80%E6%B5%8B%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p><a href="https://imgtu.com/i/Xwp7fx"><img src="https://s1.ax1x.com/2022/06/05/Xwp7fx.jpg" alt="snoarqube"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当今的大部分公司都有对自己的业务代码进行安全性审计的需求，来保证业务代码的安全性，同时代码审计作为SDL中重要的一环，可有效保证业务的CIA。但是人工审计存在严重的性能瓶颈，单纯的使用代码扫描器效果也不尽如意，误报问题较多。目前较好的方法：结合业务，自定义规则，结合两者优势。但是网上关于这方面的介绍较少，希望本文章能帮助到有需求的同学。选择的扫描为SonarQube，这款扫描器是开源扫描器中较为出色的一款，有丰富的图像化界面和强大的语法解析能力。</p><h2 id="检测流程"><a href="#检测流程" class="headerlink" title="检测流程"></a>检测流程</h2><p>扫描的基本流程是：</p><ol><li>扫描器加载插件</li><li>对扫描文件进行扫描，并解析成语法树</li><li>visitNode等方法被调用，并将解析好的语法树传入</li><li>进行自定义逻辑处理</li><li>使用reportIssue上报问题</li></ol><p><a href="https://imgtu.com/i/XwpZJx"><img src="https://s1.ax1x.com/2022/06/05/XwpZJx.jpg" alt="流程图-1.jpg"></a><br><a href="https://imgtu.com/i/XwpVF1"><img src="https://s1.ax1x.com/2022/06/05/XwpVF1.jpg" alt="流程图-2.jpg"></a></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>所以我们只需要重写visitNode方法就可以完成检测操作。当然，光有检测规则还不行，还需要一个规则定义文件和一个规则详情描述文件，如：</p><p><strong>规则文件 org.sonar.java.checks.spring.RequestMappingMethodPublicCheck</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>java<span class="token punctuation">.</span>checks<span class="token punctuation">.</span>spring<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collections<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>check<span class="token punctuation">.</span>Rule<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span>java<span class="token punctuation">.</span>api<span class="token punctuation">.</span>IssuableSubscriptionVisitor<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span>java<span class="token punctuation">.</span>api<span class="token punctuation">.</span>semantic<span class="token punctuation">.</span>Symbol<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span>java<span class="token punctuation">.</span>api<span class="token punctuation">.</span>tree<span class="token punctuation">.</span>MethodTree<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>plugins<span class="token punctuation">.</span>java<span class="token punctuation">.</span>api<span class="token punctuation">.</span>tree<span class="token punctuation">.</span>Tree<span class="token punctuation">;</span><span class="token annotation punctuation">@Rule</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">"S3751"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestMappingMethodPublicCheck</span> <span class="token keyword">extends</span> <span class="token class-name">IssuableSubscriptionVisitor</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Tree<span class="token punctuation">.</span>Kind<span class="token operator">></span> <span class="token function">nodesToVisit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>Tree<span class="token punctuation">.</span>Kind<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> CONTROLLER_ANNOTATIONS <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>    <span class="token string">"org.springframework.stereotype.Controller"</span><span class="token punctuation">,</span>    <span class="token string">"org.springframework.web.bind.annotation.RestController"</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> REQUEST_ANNOTATIONS <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>    <span class="token string">"org.springframework.web.bind.annotation.RequestMapping"</span><span class="token punctuation">,</span>    <span class="token string">"org.springframework.web.bind.annotation.GetMapping"</span><span class="token punctuation">,</span>    <span class="token string">"org.springframework.web.bind.annotation.PostMapping"</span><span class="token punctuation">,</span>    <span class="token string">"org.springframework.web.bind.annotation.PutMapping"</span><span class="token punctuation">,</span>    <span class="token string">"org.springframework.web.bind.annotation.DeleteMapping"</span><span class="token punctuation">,</span>    <span class="token string">"org.springframework.web.bind.annotation.PatchMapping"</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visitNode</span><span class="token punctuation">(</span>Tree tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasSemantic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    MethodTree methodTree <span class="token operator">=</span> <span class="token punctuation">(</span>MethodTree<span class="token punctuation">)</span> tree<span class="token punctuation">;</span>    Symbol<span class="token punctuation">.</span>MethodSymbol methodSymbol <span class="token operator">=</span> methodTree<span class="token punctuation">.</span><span class="token function">symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isClassController</span><span class="token punctuation">(</span>methodSymbol<span class="token punctuation">)</span>      <span class="token operator">&amp;&amp;</span> <span class="token function">isRequestMappingAnnotated</span><span class="token punctuation">(</span>methodSymbol<span class="token punctuation">)</span>      <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>methodSymbol<span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">reportIssue</span><span class="token punctuation">(</span>methodTree<span class="token punctuation">.</span><span class="token function">simpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"Make this method \"public\"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isClassController</span><span class="token punctuation">(</span>Symbol<span class="token punctuation">.</span>MethodSymbol methodSymbol<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> CONTROLLER_ANNOTATIONS<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>methodSymbol<span class="token punctuation">.</span><span class="token function">owner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token operator">:</span>isAnnotatedWith<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isRequestMappingAnnotated</span><span class="token punctuation">(</span>Symbol<span class="token punctuation">.</span>MethodSymbol methodSymbol<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> REQUEST_ANNOTATIONS<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>methodSymbol<span class="token punctuation">.</span><span class="token function">metadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token operator">:</span>isAnnotatedWith<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>规则定义文件 S3751_java.json</strong></p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"\"@RequestMapping\" methods should be \"public\""</span><span class="token punctuation">,</span>  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"VULNERABILITY"</span><span class="token punctuation">,</span>  <span class="token property">"status"</span><span class="token operator">:</span> <span class="token string">"ready"</span><span class="token punctuation">,</span>  <span class="token property">"remediation"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"func"</span><span class="token operator">:</span> <span class="token string">"Constant\/Issue"</span><span class="token punctuation">,</span>    <span class="token property">"constantCost"</span><span class="token operator">:</span> <span class="token string">"2min"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token property">"tags"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"spring"</span><span class="token punctuation">,</span>    <span class="token string">"owasp-a6"</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"standards"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"OWASP Top Ten"</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"defaultSeverity"</span><span class="token operator">:</span> <span class="token string">"Blocker"</span><span class="token punctuation">,</span>  <span class="token property">"ruleSpecification"</span><span class="token operator">:</span> <span class="token string">"RSPEC-3751"</span><span class="token punctuation">,</span>  <span class="token property">"sqKey"</span><span class="token operator">:</span> <span class="token string">"S3751"</span><span class="token punctuation">,</span>  <span class="token property">"scope"</span><span class="token operator">:</span> <span class="token string">"Main"</span><span class="token punctuation">,</span>  <span class="token property">"securityStandards"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"OWASP"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token string">"A6"</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>type：为该规则的类型，包括VULNERABILITY、BUG SECURITY_HOTSPOT、CODE_SMELL等。</li><li>constantCost：代表要解决该问题大概需要花费多长时间。</li><li>scope：定义要被扫描项目的范文，包括All、Main、Test。</li></ul><p><strong>规则详情描述文件 S3751_java.html</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>A method with a <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>@RequestMapping<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span> annotation part of a class annotated with <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>@Controller<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span> (directly or indirectly through ameta annotation - <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>@RestController<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span> from Spring Boot is a good example) will be called to handle matching web requests. That will happeneven if the method is <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>private<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span>, because Spring invokes such methods via reflection, without checking visibility. <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>So marking a sensitive method <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>private<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span> may seem like a good way to control how such code is called. Unfortunately, not all Springframeworks ignore visibility in this way. For instance, if you've tried to control web access to your sensitive, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>private<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>@RequestMapping<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span> method by marking it <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>@Secured<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span> ... it will still be called, whether or not the user is authorized to accessit. That's because AOP proxies are not applied to non-public methods.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>In addition to <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>@RequestMapping<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span>, this rule also considers the annotations introduced in Spring Framework 4.3: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>@GetMapping<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span>,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>@PostMapping<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span>, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>@PutMapping<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span>, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>@DeleteMapping<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span>, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>@PatchMapping<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>Noncompliant Code Example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span><span class="token punctuation">></span></span>@RequestMapping("/greet", method = GET)private String greet(String greetee) {  // Noncompliant<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pre</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>Compliant Solution<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pre</span><span class="token punctuation">></span></span>@RequestMapping("/greet", method = GET)public String greet(String greetee) {<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pre</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>See<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span> OWASP Top 10 2017 Category A6 - Security Misconfiguration <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code></pre><p>这两个文件都位于<br><code>sonar-java/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/</code>目录下，<br>我们自定义的规则json和html文件也要放在该目录下，文件名为<code>KEY_java.json KEY_java.html</code>。KEY在规则中使用<code>@Rule</code>注解定义</p><h2 id="Struts2-s2-057规则"><a href="#Struts2-s2-057规则" class="headerlink" title="Struts2 s2-057规则"></a>Struts2 s2-057规则</h2><p><strong>说明</strong>：扫描项目pom.xml中是否使用包含S2-057漏洞版本的struts2依赖</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>java<span class="token punctuation">.</span>checks<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>maven<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>java<span class="token punctuation">.</span>checks<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>maven<span class="token punctuation">.</span>helpers<span class="token punctuation">.</span>MavenDependencyCollector<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>java<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>maven<span class="token punctuation">.</span>PomCheck<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>collect<span class="token punctuation">.</span>ImmutableList<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>collect<span class="token punctuation">.</span>Lists<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>StringUtils<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>check<span class="token punctuation">.</span>Priority<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>check<span class="token punctuation">.</span>Rule<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>java<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>maven<span class="token punctuation">.</span>PomCheckContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>maven<span class="token punctuation">.</span>model<span class="token punctuation">.</span>LocatedAttribute<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>sonar<span class="token punctuation">.</span>maven<span class="token punctuation">.</span>model<span class="token punctuation">.</span>maven2<span class="token punctuation">.</span>Dependency<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Nullable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token annotation punctuation">@Rule</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">"Struts2_S2_057Check"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Struts2_S2_057Check</span> <span class="token keyword">implements</span> <span class="token class-name">PomCheck</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scanFile</span><span class="token punctuation">(</span>PomCheckContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Dependency<span class="token operator">></span> dependencies <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MavenDependencyCollector</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getMavenProject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">allDependencies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Dependency dependency <span class="token operator">:</span> dependencies<span class="token punctuation">)</span> <span class="token punctuation">{</span>            LocatedAttribute artifactId <span class="token operator">=</span> dependency<span class="token punctuation">.</span><span class="token function">getArtifactId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LocatedAttribute version <span class="token operator">=</span> dependency<span class="token punctuation">.</span><span class="token function">getVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>version <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> artifactId <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token string">"struts2-core"</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>artifactId<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">strutsVerCompare</span><span class="token punctuation">(</span>version<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String message <span class="token operator">=</span> <span class="token string">"此版本Struts2包含高危漏洞"</span><span class="token punctuation">;</span>                List<span class="token operator">&lt;</span>PomCheckContext<span class="token punctuation">.</span>Location<span class="token operator">></span> secondaries <span class="token operator">=</span> <span class="token function">getSecondary</span><span class="token punctuation">(</span>version<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> line <span class="token operator">=</span> version<span class="token punctuation">.</span><span class="token function">startLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                context<span class="token punctuation">.</span><span class="token function">reportIssue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> line<span class="token punctuation">,</span> message<span class="token punctuation">,</span> secondaries<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>PomCheckContext<span class="token punctuation">.</span>Location<span class="token operator">></span> <span class="token function">getSecondary</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> LocatedAttribute systemPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>systemPath <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> StringUtils<span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>systemPath<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PomCheckContext<span class="token punctuation">.</span>Location</span><span class="token punctuation">(</span><span class="token string">"configure check"</span><span class="token punctuation">,</span> systemPath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">strutsVerCompare</span><span class="token punctuation">(</span>String version<span class="token punctuation">)</span><span class="token punctuation">{</span>        String StrutsVersion1 <span class="token operator">=</span> <span class="token string">"2.3.35"</span><span class="token punctuation">;</span>        String StrutsVersion2 <span class="token operator">=</span> <span class="token string">"2.5.17"</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> versionArray1 <span class="token operator">=</span> version<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>versionArray1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compareVersion</span><span class="token punctuation">(</span>StrutsVersion1<span class="token punctuation">,</span> version<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>versionArray1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"5"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compareVersion</span><span class="token punctuation">(</span>StrutsVersion2<span class="token punctuation">,</span> version<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">compareVersion</span><span class="token punctuation">(</span>String version1<span class="token punctuation">,</span> String version2<span class="token punctuation">)</span><span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> versionArray1 <span class="token operator">=</span> version1<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> versionArray2 <span class="token operator">=</span> version2<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minLength <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>versionArray1<span class="token punctuation">.</span>length<span class="token punctuation">,</span> versionArray2<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> diff <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> minLength                <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>diff <span class="token operator">=</span> versionArray1<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> versionArray2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>                <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>diff <span class="token operator">=</span> versionArray1<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>versionArray2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">++</span>idx<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        diff <span class="token operator">=</span> <span class="token punctuation">(</span>diff <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> diff <span class="token operator">:</span> versionArray1<span class="token punctuation">.</span>length <span class="token operator">-</span> versionArray2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">return</span> diff<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>规则详细说明：</strong></p><ul><li><code>@Rule(key = &quot;Struts2_S2_057Check&quot;)</code>该注解声明本条规则的Key</li><li><code>implements PomCheck public void scanFile(PomCheckContext context)</code> 本条规则实现<code>PomCheck</code>类，重写<code>scanFile</code>，这样插件和扫描器会自动解析<code>Pom.xml</code>文件，并将解析完后的pom文件语法树传递进来</li><li><code>strutsVerCompare</code> 用来定义哪些版本的Struts2依赖存在漏洞</li></ul>]]></content>
      
      
      <categories>
          
          <category> security </category>
          
          <category> snoarqube </category>
          
      </categories>
      
      
        <tags>
            
            <tag> snoarqube </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
